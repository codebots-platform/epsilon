# EUnit example for testing EMF validators and Java quickfixes

This is an example project that shows how to use EUnit to perform unit testing of the validators generated by EMF into the metamodel, as well as the quickfixes implemented through a Java-based `IMarkerResolutionGenerator`.

## Structure

The example is made up by three projects:

* `org.eclipse.epsilon.eunit.examples.emfvalidator` implements the metamodel to be validated.
* `org.eclipse.epsilon.eunit.examples.emfvalidator.quickfix` implements the Java-based resolution generator.
* `org.eclipse.epsilon.eunit.examples.emfvalidator.eunit` implements the EUnit tests.

## Running the example

To try out this example:

1. Import the `emfvalidator` and `emfvalidator.quickfix` projects.
1. Run these projects as an Eclipse Application.
1. In the nested workspace, import the `emfvalidator.eunit` project.
1. Run the `Run EUnit test.launch` launch configuration.
1. All tests should pass, and you should see an editor for `example.model` left in a dirty state with the quick fix applied, showing "Model 999").
1. If you rerun the tests with the editor open, you will be asked whether you want to save the dirty state, and/or if you want to discard the changes made in the editor. Choose not to save, and to discard the editor changes.

## Metamodel

The metamodel is described in the `example.emf` file of the `emfvalidator` project, which is written in [Emfatic](https://eclipse.dev/emfatic/).
The metamodel only has a `Model` EClass, with a single `positiveValue` attribute.
`Model` has an annotation that requires the EMF code generator to produce a method for a custom Java-based validation rule (`PositiveValue`).

This annotation causes the [`EmfvalidatorValidator`](./src/org/eclipse/epsilon/eunit/examples/emfvalidator/util/EmfvalidatorValidator.java) to be generated with an additional `validateModel_PositiveValue` method, which has been manually customised to detect the case when the value is negative.

This validation will not be triggered through an Epsilon Validation Language script: it must be triggered from the EMF `Diagnostician` class.

One way to do this from the Eclipse UI is to open a model with the reflective EMF tree editor or Exeed, right-click on a model element, and select "Validate".
These tree-based editors will take the results of the `Diagnostician`, and add problem markers to the `IResource` that contains the model.

## Quickfix

The quickfix is implemented by the `MarkerResolutionGenerator` class in the `quickfix` project, which implements the `IMarkerResolutionGenerator` interface.
It is generally based on the code used for EVL-based quickfixes (see `EmfMarkerResolver`), except the resolution is implemented with plain Java instead of using EVL.

There are a few details that need to be considered for the design of the resolution generator:

* The `canResolve` method checks both the type of the marker, as well as the constraint that the message is mentioning, so it does not try to resolve other problems.
* The `run` method of the `SetToHighValueResolution` does not directly make the changes: instead, it executes an EMF command in the editing domain's command stack. This is needed to make the opened editor aware of these changes.
* The `SetToHighValueCommand` has been made as simple as possible, and does not support undo/redo. If undo/redo is desired, the ChangeDescription and ChangeRecorder classes from EMF should be used: for an example, the ExecuteEvlFixCommand class should be considered.

To make this resolution generator testable from EUnit, a few more tweaks were needed:

* The `getEditingDomain(marker)` method had to use `Display.getDefault().syncCall(...)` in order to run some of its code in the UI thread, as EUnit normally does not run code in the UI thread. This is needed in order to access the active workbench window.
* The `MarkerResolutionGenerator` class was exposed through an `org.eclipse.epsilon.common.dt.tool` extension, so Epsilon can instantiate and use it. This is explained in the ["Call Java from Epsilon"](https://eclipse.dev/epsilon/doc/articles/call-java-from-epsilon/) article of the website.
* The `MarkerResolutionGenerator` class was extended with a `getMarkerGenerator()` method which returns an instance of the `MarkerHelper` implementation used by the EMF tree editors to produce problem markers from the EMF validation. This is needed to work around a limitation in instantiating static nested classes.
* The `SetToHighValueResolution` resolution has an additional `getTarget()` method which exposes the model element being fixed, to be used from EUnit. This is because the quickfix is run in a different in-memory copy of the model than the one accessible from EUnit.

## EUnit test

The test is in the `tests.eunit` file of the `eunit` project.
There is a `build.xml` file which loads the model, disabling caching and setting `read` and `store` both to `true`.

The test is structured in this way:

1. Modify the model to ensure it violates the constraint.
1. Validate the model through the EMF `Diagnostician` class.
1. Ensure the model is considered not valid, by checking the severity of the diagnostic.
1. Use the marker helper from the EMF tree editor to turn the diagnostics into markers.
1. Dispose the model so the changes are saved: this is necessary as quickfixes are applied from editors loaded from files, and not from the model currently loaded in memory by EUnit.
1. Use the Eclipse Resources API to find the markers that have been added to the model file.
1. Use the resolution generator to compute resolutions.
1. Run the resolution.
1. Check that the model element has been fixed by the resolution as expected.
